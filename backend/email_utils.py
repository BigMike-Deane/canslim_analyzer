"""
Email utilities for CANSLIM Analyzer
Handles watchlist alerts and other email notifications
"""

import smtplib
import os
import logging
import requests
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from pathlib import Path

logger = logging.getLogger(__name__)

# Load .env file if it exists
def _load_env():
    """Load environment variables from .env file if it exists"""
    env_path = Path(__file__).parent.parent / '.env'
    if env_path.exists() and env_path.is_file():
        with open(env_path) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    os.environ[key.strip()] = value.strip()

_load_env()

# Email configuration
GMAIL_ADDRESS = os.environ.get('CANSLIM_EMAIL', 'your-email@gmail.com')
GMAIL_APP_PASSWORD = os.environ.get('CANSLIM_APP_PASSWORD', 'your-app-password')
RECIPIENT_EMAIL = os.environ.get('CANSLIM_RECIPIENT', GMAIL_ADDRESS)


def send_email(subject: str, html_content: str, text_content: str) -> bool:
    """Send email via Gmail SMTP

    Args:
        subject: Email subject line
        html_content: HTML version of the email body
        text_content: Plain text version of the email body

    Returns:
        True if email sent successfully, False otherwise
    """
    msg = MIMEMultipart('alternative')
    msg['Subject'] = subject
    msg['From'] = GMAIL_ADDRESS
    msg['To'] = RECIPIENT_EMAIL

    part1 = MIMEText(text_content, 'plain')
    part2 = MIMEText(html_content, 'html')
    msg.attach(part1)
    msg.attach(part2)

    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
            server.login(GMAIL_ADDRESS, GMAIL_APP_PASSWORD)
            server.sendmail(GMAIL_ADDRESS, RECIPIENT_EMAIL, msg.as_string())
        logger.info(f"Email sent successfully to {RECIPIENT_EMAIL}")
        return True
    except Exception as e:
        logger.error(f"Failed to send email: {e}")
        return False


def send_watchlist_alert_email(item, stock, reasons: list) -> bool:
    """Send email when watchlist alert triggers

    Args:
        item: Watchlist model instance
        stock: Stock model instance
        reasons: List of reason strings

    Returns:
        True if email sent successfully, False otherwise
    """
    subject = f"CANSLIM Alert: {item.ticker}"

    html_content = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <style>
            body {{ font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; }}
            .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }}
            .stock-info {{ background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px; }}
            .reason {{ background: #e7f5ff; padding: 10px; border-left: 4px solid #228be6; margin: 5px 0; }}
            .metric {{ display: inline-block; margin-right: 20px; }}
            .metric-value {{ font-size: 1.2em; font-weight: bold; }}
            .footer {{ color: #666; font-size: 0.9em; margin-top: 20px; }}
        </style>
    </head>
    <body>
        <div class="header">
            <h2 style="margin: 0;">Watchlist Alert Triggered</h2>
            <p style="margin: 5px 0 0 0; opacity: 0.9;">{item.ticker} has met your alert criteria</p>
        </div>

        <div class="stock-info">
            <h3 style="margin-top: 0;">{item.ticker} - {stock.name if stock.name else 'Unknown'}</h3>
            <div class="metric">
                <div style="color: #666;">Current Price</div>
                <div class="metric-value">${stock.current_price:.2f}</div>
            </div>
            <div class="metric">
                <div style="color: #666;">CANSLIM Score</div>
                <div class="metric-value">{stock.canslim_score:.0f}</div>
            </div>
        </div>

        <h3>Alert Reasons:</h3>
        {''.join(f'<div class="reason">{r}</div>' for r in reasons)}

        {f'<p><strong>Your Notes:</strong> {item.notes}</p>' if item.notes else ''}

        <div class="footer">
            <p>Generated by CANSLIM Analyzer</p>
        </div>
    </body>
    </html>
    """

    text_content = f"""Watchlist Alert: {item.ticker}

{item.ticker} - {stock.name if stock.name else 'Unknown'}

Reasons:
{chr(10).join(f'- {r}' for r in reasons)}

Current Price: ${stock.current_price:.2f}
CANSLIM Score: {stock.canslim_score:.0f}
{f'Your Notes: {item.notes}' if item.notes else ''}
"""

    return send_email(subject, html_content, text_content)


# Webhook configuration
WEBHOOK_URL = os.environ.get('CANSLIM_WEBHOOK_URL', '')


def send_webhook_notification(title: str, message: str, priority: str = "normal", data: dict = None) -> bool:
    """Send push notification via webhook (e.g., ntfy.sh, Pushover, or custom)

    The webhook receives a JSON payload with:
    - title: Notification title
    - message: Notification body
    - priority: "normal", "high", or "low"
    - data: Optional extra data dict

    Compatible with ntfy.sh, Pushover, Discord webhooks, and custom endpoints.

    Args:
        title: Notification title
        message: Notification body text
        priority: Priority level ("normal", "high", "low")
        data: Optional extra data to include in payload

    Returns:
        True if notification sent successfully, False otherwise
    """
    if not WEBHOOK_URL:
        logger.debug("Webhook URL not configured, skipping notification")
        return False

    payload = {
        "title": title,
        "message": message,
        "priority": priority,
    }
    if data:
        payload["data"] = data

    # Handle different webhook formats
    try:
        # Check for ntfy.sh style (topic-based URL)
        if "ntfy" in WEBHOOK_URL:
            # ntfy.sh uses a different format
            headers = {
                "Title": title,
                "Priority": "high" if priority == "high" else "default",
            }
            response = requests.post(WEBHOOK_URL, data=message.encode('utf-8'), headers=headers, timeout=10)
        else:
            # Standard JSON webhook (Pushover, Discord, custom)
            response = requests.post(WEBHOOK_URL, json=payload, timeout=10)

        if response.status_code in (200, 201, 204):
            logger.info(f"Webhook notification sent: {title}")
            return True
        else:
            logger.warning(f"Webhook returned status {response.status_code}: {response.text[:200]}")
            return False

    except requests.exceptions.Timeout:
        logger.error("Webhook request timed out")
        return False
    except requests.exceptions.RequestException as e:
        logger.error(f"Webhook request failed: {e}")
        return False


def send_coiled_spring_alert_webhook(stock, cs_result: dict) -> bool:
    """Send webhook notification for Coiled Spring alerts

    Args:
        stock: Stock model instance
        cs_result: Coiled Spring calculation result dict

    Returns:
        True if notification sent successfully, False otherwise
    """
    days_to_earnings = cs_result.get('days_to_earnings', 'N/A')
    base_type = cs_result.get('base_type', 'unknown')
    weeks = cs_result.get('weeks_in_base', 0)
    beat_streak = cs_result.get('beat_streak', 0)

    title = f"ðŸŒ€ Coiled Spring: {stock.ticker}"
    message = (
        f"{stock.ticker} - {getattr(stock, 'name', 'Unknown')}\n"
        f"Price: ${stock.current_price:.2f}\n"
        f"Score: {stock.canslim_score:.0f}\n"
        f"Earnings in {days_to_earnings} days\n"
        f"Base: {base_type} ({weeks}w), {beat_streak} beat streak"
    )

    data = {
        "ticker": stock.ticker,
        "price": stock.current_price,
        "score": stock.canslim_score,
        "days_to_earnings": days_to_earnings,
        "base_type": base_type,
        "weeks_in_base": weeks,
        "beat_streak": beat_streak,
    }

    return send_webhook_notification(title, message, priority="high", data=data)
